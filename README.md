# myPing utility

ping -- send ICMP ECHO_REQUEST packets to network hosts

## Introduction & features

This is a toy implementation of unix PING utility and supports the following:
```bash
usage: ./ping [-m TTL] [-t timeout] [-c count] host

-m ttl  Set the IP Time To Live for outgoing packets.  If not specified,
             the kernel uses the value of the net.inet.ip.ttl MIB variable.

-t timeout
             Specify a timeout, in seconds, before ping exits regardless of
             how many packets have been received.

-c count
             Stop after sending (and receiving) count ECHO_RESPONSE packets.
                         If this option is not specified, ping will operate until inter-
             rupted.
    
``` 

Features of the implementation:

- Sends Echo Request messages with embedded timestamps and estimates RTT between host and the client.
- Parses ****and interprets **Echo Reply** and **Time Exceeded** messages
- Supports running several instances of the binary or running along with regular `ping` at the same time  without showing ICMP packets not meant for itself
- Catches SIGINT signals and prints packet statistics before exiting
- Supports IPv4 and IPv6*(IPv6 not tested because do not have access to an IPv6 addr)

## Building and running
```bash
make
sudo ./ping [-m TTL] [-t timeout] [-c count] host
```
Note that superuser privileges are necessary by the nature of ICMP packets. These require raw sockets and in *nix systems only superuser can work with raw sockets.

You can avoid typing sudo every type by setting uid pit on `ping` binary and giving ownership of it to root.(commands are different on macs. Makefile has a target for doing this in both systems)
```bash
chown root:root ping
chmod u+s ping
```
The code was tested on Mac 10.14.6(Mojave) and Ubuntu 18.04.3 LTS.

## Testing

Although some regression tests are included in the repository, the bulk of testing was done offline through Wireshark and by running multiple instance of the binary in changing network conditions (e.g. unreliable networks, packet blocking, packet mingling through Wireshark, etc. )

Below is a non-exhaustive list of the performed tests:

- Run `myping` along with `ping`/`traceroute` or another instance of `myping`
- Turn on/off the internet connection thereby changing reachability of remote host
- Send SIGINT signals at various points of execution to assure expected behaviour.
- Cause packet delays and assure their late arrival does not throttle the echo-reply cycle and the delayed replies are successfully ignored.
- Run the program under users with different permissions

To run the regression test suit (requires visual inspection for correct behaviour)
```bash
make test
```

The tests are generated by the attached [python script](./testgen.py) and in the presence of python interpreter can be regenerated by running
```bash
make testgen
```
## C Implementation details

The program is implemented on POSIX network API and uses raw sockets to build ICMP packets.

Current process `pid` is used as ICMP Echo Request id in the header which allows several execution instances of the binary and other ICMP utilities without interference in their packets.

Argument parsing is implemented with `getopt`

---

### sudo

The program requires elevated privileges (sudo) on most systems but since POSIX has no root user requirement, instead of checking for uid, I attempt creating the raw socket and report possible need of elevated privileges if it fails
```C
if ((sockfd = socket(p->ai_family, SOCK_RAW, IPPROTO_ICMP)) == -1) {
            if (EPERM == errno) {
                fprintf(stderr, "myping: Operation not permitted\n"
                                 "...");
                exit(1);
            }
            perror("myping: socket\n");
            continue;
        }
```
### Delayed packets and staying in sync

I use `sendto` and `recvfrom` to perform connectionless socket communication. Just as the regular `ping`, I consider packets lost after some timeout even if these arrive at a later time.

I do this by checking whether this is the packet I expected every time I receive an ICMP packet
```C
do {
    status = recvfrom(sockfd, packet, sizeof(packet), 0, &wherefrom, &wherefrom_len);
    // could reuse send_time if desperate for space, but this is clearer
    gettimeofday(&recv_time, NULL);

    ip_handle_if_timexceed(packet);
    // packet must be at least 44 bytes. If it is not, there was an error
    if (status < sizeof(struct ip) + ICMP_HEADER_SIZE + sizeof(struct timeval)) continue;
    ip_header = (struct ip *) packet;
    icmp_header = (struct icmp *) (packet + sizeof(struct ip));
} while (status != -1 && icmp_is_valid_reply((char *) icmp_header, seq_num) == -1);
```
If the packet does not have the correct `icmp_seq` number, it must be a delayed packet or corrupted. Either case, I need to keep receiving packets before continuing the outer loop as otherwise one dropped or late packet could through all `icmp_seq`s out of sync.

### Signals

I set up signal handlers to prints statistics upon exit. The handlers are not reentrant but this is not a problem here since the handlers do not reestablish the signals
```C
signal(SIGINT, exit_with_stats);
signal(SIGALRM, exit_with_stats);
if (timeout != -1) alarm(timeout);
```
There may still be an issue since, for example an alarm may ring right after we send SIGINT thereby resulting the handler be called twice (at least partly) and possibly put the print buffer in an undesirable state. For this reason signal handlers are removed before proceeding to non-reentrant calls in the handler
```C
void exit_with_stats(int sig_num) {
    signal(SIGINT, SIG_DFL);
    signal(SIGALRM, SIG_DFL);
        ...
        prinf(...);
        exit(0);
}
```
### Timeout

Initially packet timeout is set to 1second but after 3 iterations it is reset to `2*RTT` where `RTT` is the average round trip time so far. This helps make the program move faster in case of network partitions
```C
if (rtt_time_stats.cnt == 3) {
    /* improvising here:
     * Wait some time to accumulate data then update recv_time
     */
    memset(&recv_timeout, 0, sizeof(recv_timeout));
    // TIMEOUT = 2*RTT
    recv_timeout.tv_usec = 2 * rtt_time_stats.sum * 1000.0 / rtt_time_stats.cnt;
    setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, (const char *) &recv_timeout, sizeof(recv_timeout));
}
```
### Packet Size

`packet` is what holds the data read from the socket and it needs to be large enough for all scenarios. Because our `Echo Request` packet has only 16 bytes of data, 44 bytes is sufficient for handling replies. However, to successfully handle Time Exceeded messages, we need more since those include additional ICMP and IP headers( and more? depending on the server sending them).
```C
// echo reply:     20(ip header) + 8(ICMP header) + 16(timestamp)
// time exceeded:  20(ip header) + 8(ICMP header) + 20(orig ip header) + 8 (ICMP header )+ [8 (8 bits of orig data)]
char packet[sizeof(struct ip) + ICMP_HEADER_SIZE + sizeof(struct ip) + ICMP_HEADER_SIZE];
```
### Handling Time Exceeded

The main difficulty with handling Time Exceeded was in parsing the nested headers. This is necessary for retrieving the original ICMP `id` which is used to only print Time Exceeded info if we were the source of the original ICMP packet. This again makes it possible for the program to be executed independently from its other instances and independently from other ICMP dependent programs
```C
struct ip *ip_header = (struct ip *) packet;
struct icmp *icmp_header = (struct icmp *) (packet + sizeof(struct ip));

/* struct icmp is larger than the header it represents hence using a const */
struct ip *nested_ip_header = (struct ip *) (packet + sizeof(struct ip) + ICMP_HEADER_SIZE);
struct icmp *nested_icmp_header = (struct icmp *) (packet + sizeof(struct ip) + ICMP_HEADER_SIZE +
                                                   sizeof(struct ip));
if (size == -1) return;

checksum = icmp_header->icmp_cksum;
icmp_header->icmp_cksum = 0;
icmp_header->icmp_cksum = icmp_checksum((char *) icmp_header, size - sizeof(struct ip));

/*todo:: after hours of work still could not get the time exceeded message checksum to check out...*/
if (/* icmp_header->icmp_cksum == checksum && */
        nested_icmp_header->icmp_id == ICMP_ID &&
        icmp_header->icmp_type == ICMP_TIMXCEED &&
        icmp_header->icmp_code == ICMP_TIMXCEED_INTRANS) {
    printf("%d bytes from %s: Time to live exceeded \n", size, inet_ntoa(ip_header->ip_src));
    printf("Src\t\tDst\n");
    // N.B the next two need to be in separate lines since inet_ntoa uses a single static buffer
    printf("%s\t", inet_ntoa(nested_ip_header->ip_src));
    printf("%s\n", inet_ntoa(nested_ip_header->ip_dst));
}
```
### Road to IpV6

I did not test the utility on IPv6 hosts since my internet provider does support IPv6. Neither did my EC2 instance for that matter or the university VPN...

Just looking through the code, `inet_ntoa` seems to be the only problem for having the code work on IPv6 and it can easily be replaced with `inet_ntop`. I did not do that because I would not be able to test it.

### Future Work

After hours of work I still was not able to get the checksum check out for Time Exceeded messages. It is parsed and checked just fine for regular Echo Reply messages so I am confident that my checksum implementation is correct (it also is just a direct copy paste from [RFC1071](https://tools.ietf.org/html/rfc1071))

---

## References

1. Computing the Internet Checksum, [https://tools.ietf.org/html/rfc1071](https://tools.ietf.org/html/rfc1071)
2. ICMP, [https://tools.ietf.org/html/rfc792](https://tools.ietf.org/html/rfc792)
3. ICMPv6,  [https://tools.ietf.org/html/rfc4443](https://tools.ietf.org/html/rfc4443)
4. `man` pages (sections 3-5)
5. Beej's Guide to Network Programming, [https://beej.us/guide/bgnet/html/#recvman](https://beej.us/guide/bgnet/html/#recvman)
6. Haken Cockroach King, [https://www.youtube.com/watch?v=0_e4YX73Ww4](https://www.youtube.com/watch?v=0_e4YX73Ww4)